// Generated by ChatGPT
// 14.02.2025

import SwiftUI
import MetalKit

// MARK: - Perlin Noise
fileprivate let p: [Int] = {
    // Standard Perlin permutation array
    let base: [Int] = [
        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,
        140,36,103,30,69,142,8,99,37,240,21,10,23,190, 6,148,
        247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,
        32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,
        68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,
        111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,
        244,102,143,54,65,25,63,161, 1,216,80,73,209,76,132,
        187,208, 89,18,169,200,196,135,130,116,188,159,86,164,
        100,109,198,173,186, 3,64,52,217,226,250,124,123, 5,
        202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,
        58,17,182,189,28,42,223,183,170,213,119,248,152, 2,44,
        154,163, 70,221,153,101,155,167, 43,172, 9,129,22,39,
        253, 19,98,108,110,79,113,224,232,178,185,112,104,218,
        246,97,228,251,34,242,193,238,210,144,12,191,179,162,
        241, 81,51,145,235,249,14,239,107, 49,192,214, 31,181,
        199,106,157,184, 84,204,176,115,121, 50,45,127,  4,150
    ]
    // Repeat for indexing
    return base + base
}()

fileprivate func fade(_ t: Float) -> Float {
    t * t * t * (t * (t * 6 - 15) + 10)
}

fileprivate func grad(_ hash: Int, _ x: Float, _ y: Float) -> Float {
    let h = hash & 3
    let u = h < 2 ? x : y
    let v = h < 2 ? y : x
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v)
}

// Simple 2D Perlin
fileprivate func perlin(_ x: Float, _ y: Float) -> Float {
    let X = Int(floor(x)) & 255
    let Y = Int(floor(y)) & 255
    
    let xf = x - floor(x)
    let yf = y - floor(y)
    
    let u = fade(xf)
    let v = fade(yf)
    
    let aa = p[p[X] + Y]
    let ab = p[p[X] + Y + 1]
    let ba = p[p[X + 1] + Y]
    let bb = p[p[X + 1] + Y + 1]
    
    let gAA = grad(aa, xf, yf)
    let gBA = grad(ba, xf - 1, yf)
    let gAB = grad(ab, xf, yf - 1)
    let gBB = grad(bb, xf - 1, yf - 1)
    
    let x1 = simd_mix(gAA, gBA, u)
    let x2 = simd_mix(gAB, gBB, u)
    let y1 = simd_mix(x1, x2, v)
    // Scale to [-1..1]
    return y1
}

// MARK: - Flow Texture Generator
func generatePerlinFlowTexture(device: MTLDevice,
                               width: Int = 128,
                               height: Int = 128,
                               scale: Float = 20) -> MTLTexture? {
    let descriptor = MTLTextureDescriptor()
    descriptor.pixelFormat = .rgba8Unorm
    descriptor.width = width
    descriptor.height = height
    descriptor.usage = [.shaderRead]
    
    guard let texture = device.makeTexture(descriptor: descriptor) else {
        return nil
    }
    
    // RG channels will store flow vectors
    var pixels = [UInt8](repeating: 0, count: width * height * 4)
    
    for y in 0..<height {
        for x in 0..<width {
            let nx = Float(x) / scale
            let ny = Float(y) / scale
            // 2D Perlin-based offsets
            let flowX = (perlin(nx, ny) + 1) / 2  // [0..1]
            let flowY = (perlin(nx + 100, ny + 100) + 1) / 2 // shift coords
            
            let i = (y * width + x) * 4
            // map flow to [0..255]
            pixels[i + 0] = UInt8(flowX * 255) // R
            pixels[i + 1] = UInt8(flowY * 255) // G
            pixels[i + 2] = 0                  // B
            pixels[i + 3] = 255                // A
        }
    }
    
    let region = MTLRegion(origin: MTLOrigin(x: 0, y: 0, z: 0),
                           size: MTLSize(width: width, height: height, depth: 1))
    texture.replace(region: region,
                    mipmapLevel: 0,
                    withBytes: pixels,
                    bytesPerRow: width * 4)
    
    return texture
}

func makePerlinImage(width: Int = 128,
                     height: Int = 128,
                     scale: Float = 20) -> Image? {
    // RGBA byte buffer
    var pixels = [UInt8](repeating: 0, count: width * height * 4)
    
    for y in 0..<height {
        for x in 0..<width {
            let nx = Float(x) / scale
            let ny = Float(y) / scale
            let noise1 = (perlin(nx, ny) + 1) * 0.5 // [0..1]
            // Offshift so second sample is different:
            let noise2 = (perlin(nx + 100, ny + 100) + 1) * 0.5

            // Map to [0..255]
            let idx = (y * width + x) * 4
            pixels[idx + 0] = UInt8(noise1 * 255) // R
            pixels[idx + 1] = UInt8(noise2 * 255) // G
            pixels[idx + 2] = 0                   // B
            pixels[idx + 3] = 255                 // A
        }
    }
    
    // Create a CGImage
    let colorSpace = CGColorSpaceCreateDeviceRGB()
    let context = CGContext(
        data: &pixels,
        width: width,
        height: height,
        bitsPerComponent: 8,
        bytesPerRow: width * 4,
        space: colorSpace,
        bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
    )!
    if let cgImage: CGImage = context.makeImage() {
        return Image(decorative: cgImage, scale: 1)
    }
    return nil
//    guard let cgImage = context.makeImage() else {
//        return Image(systemName: "exclamationmark.triangle")
//    }
    
    // Convert CGImage -> SwiftUI Image
//    return Image(decorative: cgImage, scale: 1)
    
}
